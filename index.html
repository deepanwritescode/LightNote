<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Light Note</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #1a1a1a;
      position: fixed;
      width: 100%;
      height: 100%;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: grab;
      background: #1a1a1a;
      position: fixed;
      top: 0;
      left: 0;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    #canvas:active {
      cursor: grabbing;
    }

    .context-menu {
      position: fixed;
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
      padding: 4px 0;
      z-index: 1000;
      min-width: 150px;
    }

    .context-menu-item {
      padding: 14px 20px;
      cursor: pointer;
      font-size: 16px;
      color: #e0e0e0;
    }

    .context-menu-item:hover {
      background: #3a3a3a;
    }

    .note-editor {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2a2a2a;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.6);
      width: 500px;
      max-width: 90vw;
      z-index: 2000;
      display: none;
      border: 1px solid #3a3a3a;
    }

    .note-editor.active {
      display: block;
    }

    .note-editor-header {
      padding: 16px 16px 8px 16px;
    }

    .note-editor-title {
      width: 100%;
      border: none;
      outline: none;
      font-size: 18px;
      font-weight: 500;
      padding: 8px 0;
      font-family: inherit;
      background: transparent;
      color: #e0e0e0;
    }

    .note-editor-title::placeholder {
      color: #666;
    }

    .note-editor-body {
      padding: 8px 16px;
    }

    .note-editor-content {
      width: 100%;
      border: none;
      outline: none;
      font-size: 14px;
      min-height: 200px;
      resize: vertical;
      font-family: inherit;
      line-height: 1.5;
      white-space: pre-wrap;
      background: transparent;
      color: #e0e0e0;
      -webkit-user-select: text;
      user-select: text;
    }

    .note-editor-content::placeholder {
      color: #666;
    }

    .linked-text {
      color: #ff69b4;
      text-decoration: underline;
      cursor: pointer;
      background: rgba(124, 58, 237, 0.1);
      padding: 2px 4px;
      border-radius: 3px;
    }

    .linked-text:hover {
      background: rgba(124, 58, 237, 0.2);
    }

    .links-popup {
      position: absolute;
      background: #2a2a2a;
      border: 1px solid #3a3a3a;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
      padding: 8px 0;
      z-index: 2500;
      min-width: 200px;
      max-width: 300px;
    }

    .links-popup-item {
      padding: 10px 16px;
      cursor: pointer;
      font-size: 14px;
      color: #e0e0e0;
      border-bottom: 1px solid #3a3a3a;
    }

    .links-popup-item:last-child {
      border-bottom: none;
    }

    .links-popup-item:hover {
      background: #3a3a3a;
    }

    .links-popup-title {
      font-weight: 600;
      color: #a78bfa;
    }

    .links-popup-text {
      font-size: 12px;
      color: #999;
      margin-top: 4px;
    }

    .note-editor-toolbar {
      padding: 8px 16px;
      display: flex;
      gap: 8px;
      border-top: 1px solid #3a3a3a;
    }

    .toolbar-btn {
      padding: 6px 12px;
      border: 1px solid #3a3a3a;
      background: #2a2a2a;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: #e0e0e0;
    }

    .toolbar-btn:hover {
      background: #3a3a3a;
    }

    .toolbar-btn.active {
      background: #2d1b4e;
      border-color: #7c3aed;
    }

    .note-editor-footer {
      padding: 12px 16px;
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .btn {
      padding: 8px 24px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    .btn-primary {
      background: #7c3aed;
      color: white;
    }

    .btn-primary:hover {
      background: #6d28d9;
    }

    .btn-secondary {
      background: transparent;
      color: #999;
    }

    .btn-secondary:hover {
      background: #3a3a3a;
    }

    .link-mode-overlay {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1500;
      display: none;
      pointer-events: none;
    }

    .link-mode-overlay.active {
      display: block;
    }

    .link-mode-message {
      background: #2a2a2a;
      padding: 16px 32px;
      border-radius: 8px;
      font-size: 16px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.6);
      border: 2px solid #7c3aed;
      color: #e0e0e0;
    }

    .text-selection-mode {
      cursor: text !important;
    }

    .login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #1a1a1a;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .login-box {
      background: #2a2a2a;
      padding: 40px;
      border-radius: 12px;
      box-shadow: 0 4px 30px rgba(0,0,0,0.6);
      text-align: center;
      border: 1px solid #3a3a3a;
      max-width: 400px;
    }

    .login-box h1 {
      color: #e0e0e0;
      margin-bottom: 10px;
      font-size: 28px;
    }

    .login-box p {
      color: #999;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .google-signin-btn {
      background: white;
      color: #444;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 12px;
      transition: box-shadow 0.2s;
    }

    .google-signin-btn:hover {
      box-shadow: 0 2px 8px rgba(255,255,255,0.2);
    }

    .user-info {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #2a2a2a;
      padding: 12px 20px;
      border-radius: 8px;
      border: 1px solid #3a3a3a;
      display: flex;
      align-items: center;
      gap: 12px;
      z-index: 1000;
    }

    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid #7c3aed;
    }

    .user-name {
      color: #e0e0e0;
      font-size: 14px;
      font-weight: 500;
    }

    .logout-btn {
      background: transparent;
      color: #999;
      border: 1px solid #3a3a3a;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      margin-left: 8px;
    }

    .logout-btn:hover {
      background: #3a3a3a;
      color: #e0e0e0;
    }

    .drag-hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #2a2a2a;
      padding: 12px 24px;
      border-radius: 8px;
      border: 1px solid #3a3a3a;
      color: #e0e0e0;
      font-size: 14px;
      z-index: 500;
      display: none;
      pointer-events: none;
    }

    .drag-hint.show {
      display: block;
    }

    .mobile-action-buttons {
      display: none;
      gap: 8px;
      margin-top: 12px;
    }

    .mobile-action-buttons.show {
      display: flex;
    }

    .mobile-btn {
      flex: 1;
      padding: 10px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: white;
    }

    .mobile-btn-link {
      background: #7c3aed;
    }

    .mobile-btn-link:active {
      background: #6d28d9;
    }

    .mobile-btn-delete {
      background: #dc2626;
    }

    .mobile-btn-delete:active {
      background: #b91c1c;
    }
  </style>
</head>
<body>
  <div id="loginOverlay" class="login-overlay">
    <div class="login-box">
      <h1>Light Note</h1>
      <p>Sign in to access your personal note graph</p>
      <button id="googleSignInBtn" class="google-signin-btn">
        <svg width="18" height="18" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><path d="M17.6 9.2l-.1-1.8H9v3.4h4.8C13.6 12 13 13 12 13.6v2.2h3a8.8 8.8 0 0 0 2.6-6.6z" fill="#4285F4"/><path d="M9 18c2.4 0 4.5-.8 6-2.2l-3-2.2a5.4 5.4 0 0 1-8-2.9H1V13a9 9 0 0 0 8 5z" fill="#34A853"/><path d="M4 10.7a5.4 5.4 0 0 1 0-3.4V5H1a9 9 0 0 0 0 8l3-2.3z" fill="#FBBC05"/><path d="M9 3.6c1.3 0 2.5.4 3.4 1.3L15 2.3A9 9 0 0 0 1 5l3 2.4a5.4 5.4 0 0 1 5-3.7z" fill="#EA4335"/></g></svg>
        Sign in with Google
      </button>
    </div>
  </div>

  <div id="userInfo" class="user-info" style="display: none;">
    <img id="userAvatar" class="user-avatar" src="" alt="User">
    <span id="userName" class="user-name"></span>
    <button id="logoutBtn" class="logout-btn">Sign Out</button>
  </div>

  <canvas id="canvas"></canvas>
  <div id="linkModeOverlay" class="link-mode-overlay">
    <div class="link-mode-message">Select a note to link to</div>
  </div>

  <div id="dragHint" class="drag-hint">
    Hold to drag
  </div>

  <!-- Firebase Scripts -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>

  <script>
    // Firebase Configuration & Initialization
    const firebaseConfig = {
      apiKey: "AIzaSyBZdRiJlSLZMqdMCPiRmbv6A-kzFg4dVgs",
      authDomain: "lightnote-coffeecorvid.firebaseapp.com",
      projectId: "lightnote-coffeecorvid",
      storageBucket: "lightnote-coffeecorvid.firebasestorage.app",
      messagingSenderId: "842228608724",
      appId: "1:842228608724:web:5312ed1f38ab05ca461541",
      measurementId: "G-N6M2QS6S00"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    
    let currentUser = null;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: false });
    
    // Fix for mobile DPI
    function resizeCanvasForDevice() {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      
      ctx.scale(dpr, dpr);
    }
    
    resizeCanvasForDevice();
    window.addEventListener('resize', resizeCanvasForDevice);

    let notes = [];
    let links = [];
    let camera = { x: 0, y: 0, zoom: 1 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let selectedNote = null;
    let contextMenu = null;
    let noteEditor = null;
    let linkMode = null;
    let draggingNote = null;
    let linksPopup = null;
    let hasDragged = false;
    let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Touch variables
    let touchStartTime = 0;
    let touchStartPos = { x: 0, y: 0 };
    let touchStartNote = null;
    let longPressTimer = null;
    let isLongPress = false;
    let lastTapTime = 0;
    let lastTapNote = null;
    const LONG_PRESS_DURATION = 500;
    const DOUBLE_TAP_DELAY = 300;

    class Note {
      constructor(x, y, title = '', content = '') {
        this.id = Date.now() + Math.random();
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.title = title;
        this.content = content;
        this.radius = 12;
        this.isDragging = false;
      }
    }

    class Link {
      constructor(from, to, fromText, toText) {
        this.from = from;
        this.to = to;
        this.fromText = fromText;
        this.toText = toText;
      }
    }

    function screenToWorld(sx, sy) {
      return {
        x: (sx - canvas.clientWidth / 2) / camera.zoom - camera.x,
        y: (sy - canvas.clientHeight / 2) / camera.zoom - camera.y
      };
    }

    function worldToScreen(wx, wy) {
      return {
        x: (wx + camera.x) * camera.zoom + canvas.clientWidth / 2,
        y: (wy + camera.y) * camera.zoom + canvas.clientHeight / 2
      };
    }

    function applyForces() {
      const repulsion = 4000;
      const attraction = 0.005;
      const damping = 0.85;
      const centerPull = 0.001;

      for (let i = 0; i < notes.length; i++) {
        if (notes[i].isDragging) continue;
        
        for (let j = i + 1; j < notes.length; j++) {
          if (notes[j].isDragging) continue;
          
          const dx = notes[j].x - notes[i].x;
          const dy = notes[j].y - notes[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = repulsion / (dist * dist);
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          notes[i].vx -= fx;
          notes[i].vy -= fy;
          notes[j].vx += fx;
          notes[j].vy += fy;
        }
      }

      links.forEach(link => {
        const dx = link.to.x - link.from.x;
        const dy = link.to.y - link.from.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const desiredDist = 200;
        const force = (dist - desiredDist) * attraction;
        const fx = (dx / dist) * force;
        const fy = (dy / dist) * force;
        
        if (!link.from.isDragging) {
          link.from.vx += fx;
          link.from.vy += fy;
        }
        if (!link.to.isDragging) {
          link.to.vx -= fx;
          link.to.vy -= fy;
        }
      });

      notes.forEach(note => {
        if (note.isDragging) {
          note.vx = 0;
          note.vy = 0;
          return;
        }
        
        note.vx += -note.x * centerPull;
        note.vy += -note.y * centerPull;
        note.vx *= damping;
        note.vy *= damping;
        note.x += note.vx;
        note.y += note.vy;
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      const gridSize = 40;
      const dotRadius = 1.5;
      ctx.fillStyle = '#333333';
      
      const startX = Math.floor(((-camera.x - canvas.clientWidth / 2 / camera.zoom) / gridSize)) * gridSize;
      const startY = Math.floor(((-camera.y - canvas.clientHeight / 2 / camera.zoom) / gridSize)) * gridSize;
      const endX = startX + canvas.clientWidth / camera.zoom + gridSize * 2;
      const endY = startY + canvas.clientHeight / camera.zoom + gridSize * 2;
      
      for (let x = startX; x < endX; x += gridSize) {
        for (let y = startY; y < endY; y += gridSize) {
          const screen = worldToScreen(x, y);
          ctx.beginPath();
          ctx.arc(screen.x, screen.y, dotRadius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.strokeStyle = '#555';
      ctx.lineWidth = 2;
      links.forEach(link => {
        const from = worldToScreen(link.from.x, link.from.y);
        const to = worldToScreen(link.to.x, link.to.y);
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      });

      notes.forEach(note => {
        const pos = worldToScreen(note.x, note.y);
        
        ctx.fillStyle = '#a78bfa';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, note.radius * camera.zoom, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        if (note.title) {
          ctx.fillStyle = '#e0e0e0';
          ctx.font = `${12 * camera.zoom}px Arial`;
          ctx.textAlign = 'center';
          ctx.fillText(note.title, pos.x, pos.y + (note.radius + 15) * camera.zoom);
        }
      });
    }

    function getNoteAt(sx, sy) {
      const world = screenToWorld(sx, sy);
      for (let note of notes) {
        const dx = world.x - note.x;
        const dy = world.y - note.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < note.radius) {
          return note;
        }
      }
      return null;
    }

    function animate() {
      applyForces();
      draw();
      requestAnimationFrame(animate);
    }

    function showContextMenu(x, y, note) {
      removeContextMenu();
      contextMenu = document.createElement('div');
      contextMenu.className = 'context-menu';
      
      if (isMobile) {
        contextMenu.style.left = '50%';
        contextMenu.style.top = '50%';
        contextMenu.style.transform = 'translate(-50%, -50%)';
      } else {
        contextMenu.style.left = x + 'px';
        contextMenu.style.top = y + 'px';
      }

      if (note) {
        const addLinkItem = document.createElement('div');
        addLinkItem.className = 'context-menu-item';
        addLinkItem.textContent = 'Add Link';
        addLinkItem.onclick = () => {
          removeContextMenu();
          startLinkCreation(note);
        };
        contextMenu.appendChild(addLinkItem);

        const deleteItem = document.createElement('div');
        deleteItem.className = 'context-menu-item';
        deleteItem.textContent = 'Delete Note';
        deleteItem.onclick = () => {
          removeContextMenu();
          deleteNote(note);
        };
        contextMenu.appendChild(deleteItem);
      } else {
        const newNoteItem = document.createElement('div');
        newNoteItem.className = 'context-menu-item';
        newNoteItem.textContent = 'New Note';
        newNoteItem.onclick = () => {
          removeContextMenu();
          const world = screenToWorld(x, y);
          createNote(world.x, world.y);
        };
        contextMenu.appendChild(newNoteItem);
      }

      document.body.appendChild(contextMenu);
    }

    function removeContextMenu() {
      if (contextMenu) {
        contextMenu.remove();
        contextMenu = null;
      }
    }

    function showNoteEditor(note, onSave, mode = 'edit', scrollToText = null, isMobileEditor = false) {
      removeNoteEditor();
      removeLinksPopup();
      
      noteEditor = document.createElement('div');
      noteEditor.className = 'note-editor active';
      
      const noteLinks = getLinksForNote(note);
      let displayContent = note.content;
      let displayTitle = note.title;
      
      if (mode === 'edit') {
        displayContent = renderLinkedText(note.content, noteLinks, note);
        displayTitle = renderLinkedText(note.title, noteLinks, note);
      }
      
      const mobileActionsHTML = isMobileEditor && mode === 'edit' ? `
        <div class="mobile-action-buttons show">
          <button class="mobile-btn mobile-btn-link" id="editorLinkBtn">Add Link</button>
          <button class="mobile-btn mobile-btn-delete" id="editorDeleteBtn">Delete</button>
        </div>
      ` : '';

      const html = `
        <div class="note-editor-header">
          <div class="note-editor-title-display">${displayTitle}</div>
          <input type="text" class="note-editor-title" placeholder="Title" value="${note.title}" style="display: none;">
        </div>
        <div class="note-editor-body">
          <div class="note-editor-content" contenteditable="true">${displayContent}</div>
        </div>
        <div class="note-editor-toolbar">
          <button class="toolbar-btn" data-format="bold"><b>B</b></button>
          <button class="toolbar-btn" data-format="italic"><i>I</i></button>
          <button class="toolbar-btn" data-format="underline"><u>U</u></button>
        </div>
        ${mobileActionsHTML}
        <div class="note-editor-footer">
          <button class="btn btn-secondary" id="cancelBtn">Cancel</button>
          <button class="btn btn-primary" id="saveBtn">${mode === 'select' ? 'Confirm' : 'Save'}</button>
        </div>
      `;
      
      noteEditor.innerHTML = html;
      document.body.appendChild(noteEditor);

      const titleDisplay = noteEditor.querySelector('.note-editor-title-display');
      const titleInput = noteEditor.querySelector('.note-editor-title');
      const contentArea = noteEditor.querySelector('.note-editor-content');
      const saveBtn = noteEditor.querySelector('#saveBtn');
      const cancelBtn = noteEditor.querySelector('#cancelBtn');

      if (mode === 'edit') {
        // Handle linked text clicks in both title and content
        const handleLinkedTextClick = (e) => {
          const target = e.target.closest('.linked-text');
          if (target) {
            e.preventDefault();
            const linkText = target.textContent;
            showLinksPopup(e.clientX, e.clientY, note, linkText);
          }
        };
        
        contentArea.addEventListener('contextmenu', handleLinkedTextClick);
        titleDisplay.addEventListener('contextmenu', handleLinkedTextClick);
        titleDisplay.addEventListener('click', handleLinkedTextClick);
      }

      if (scrollToText && mode === 'edit') {
        setTimeout(() => {
          const linkedSpans = contentArea.querySelectorAll('.linked-text');
          for (let span of linkedSpans) {
            if (span.textContent === scrollToText) {
              span.scrollIntoView({ behavior: 'smooth', block: 'center' });
              span.style.background = 'rgba(124, 58, 237, 0.3)';
              setTimeout(() => {
                span.style.background = 'rgba(124, 58, 237, 0.1)';
              }, 1000);
              break;
            }
          }
        }, 100);
      }

      noteEditor.querySelectorAll('[data-format]').forEach(btn => {
        btn.onclick = () => {
          document.execCommand(btn.dataset.format, false, null);
          contentArea.focus();
        };
      });

      // Mobile action buttons
      if (isMobileEditor && mode === 'edit') {
        const editorLinkBtn = noteEditor.querySelector('#editorLinkBtn');
        const editorDeleteBtn = noteEditor.querySelector('#editorDeleteBtn');

        if (editorLinkBtn) {
          editorLinkBtn.onclick = () => {
            note.title = titleInput.value;
            note.content = contentArea.innerText;
            removeNoteEditor();
            startLinkCreation(note);
          };
        }

        if (editorDeleteBtn) {
          editorDeleteBtn.onclick = () => {
            removeNoteEditor();
            deleteNote(note);
            scheduleSave();
          };
        }
      }

      if (mode === 'select') {
        contentArea.contentEditable = 'false';
        contentArea.style.cursor = 'text';
        contentArea.style.userSelect = 'text';
        
        saveBtn.onclick = () => {
          const selection = window.getSelection();
          if (!selection.toString()) {
            alert('Please select some text');
            return;
          }
          const selectedText = selection.toString();
          onSave(selectedText);
          removeNoteEditor();
        };
      } else {
        saveBtn.onclick = () => {
          note.title = titleInput.value;
          note.content = contentArea.innerText;
          onSave(note);
          removeNoteEditor();
        };

        // Show/hide title input on focus
        titleInput.addEventListener('focus', () => {
          titleDisplay.style.display = 'none';
          titleInput.style.display = 'block';
          titleInput.focus();
        });

        titleInput.addEventListener('blur', () => {
          titleDisplay.style.display = 'block';
          titleInput.style.display = 'none';
          titleDisplay.innerHTML = renderLinkedText(titleInput.value, getLinksForNote(note), note);
        });
      }

      cancelBtn.onclick = () => {
        removeNoteEditor();
        if (linkMode) linkMode = null;
      };

      titleInput.focus();
    }

    function removeNoteEditor() {
      if (noteEditor) {
        noteEditor.remove();
        noteEditor = null;
      }
    }

    function getLinksForNote(note) {
      const result = [];
      links.forEach(link => {
        if (link.from.id === note.id) {
          result.push({ text: link.fromText, targetNote: link.to, targetText: link.toText });
        }
        if (link.to.id === note.id) {
          result.push({ text: link.toText, targetNote: link.from, targetText: link.fromText });
        }
      });
      return result;
    }

    function renderLinkedText(content, noteLinks, currentNote) {
      let rendered = content;
      const replacements = [];
      
      noteLinks.forEach(link => {
        const index = rendered.indexOf(link.text);
        if (index !== -1) {
          replacements.push({
            start: index,
            end: index + link.text.length,
            text: link.text,
            html: `<span class="linked-text" data-link-text="${link.text}">${link.text}</span>`
          });
        }
      });
      
      replacements.sort((a, b) => b.start - a.start);
      replacements.forEach(r => {
        rendered = rendered.substring(0, r.start) + r.html + rendered.substring(r.end);
      });
      
      return rendered;
    }

    function showLinksPopup(x, y, note, linkText) {
      removeLinksPopup();
      
      const relevantLinks = [];
      links.forEach(link => {
        if (link.from.id === note.id && link.fromText === linkText) {
          relevantLinks.push({ targetNote: link.to, targetText: link.toText });
        }
        if (link.to.id === note.id && link.toText === linkText) {
          relevantLinks.push({ targetNote: link.from, targetText: link.fromText });
        }
      });
      
      if (relevantLinks.length === 0) return;
      
      linksPopup = document.createElement('div');
      linksPopup.className = 'links-popup';
      linksPopup.style.left = x + 'px';
      linksPopup.style.top = y + 'px';
      
      relevantLinks.forEach(link => {
        const item = document.createElement('div');
        item.className = 'links-popup-item';
        item.innerHTML = `
          <div class="links-popup-title">${link.targetNote.title || 'Untitled'}</div>
          <div class="links-popup-text">"${link.targetText}"</div>
        `;
        item.onclick = () => {
          removeLinksPopup();
          removeNoteEditor();
          showNoteEditor(link.targetNote, (savedNote) => {}, 'edit', link.targetText);
        };
        linksPopup.appendChild(item);
      });
      
      document.body.appendChild(linksPopup);
    }

    function removeLinksPopup() {
      if (linksPopup) {
        linksPopup.remove();
        linksPopup = null;
      }
    }

    async function saveToFirebase() {
      if (!currentUser) return;
      
      try {
        const notesData = notes.map(note => ({
          id: note.id,
          x: note.x,
          y: note.y,
          title: note.title,
          content: note.content,
          radius: note.radius
        }));
        
        const linksData = links.map(link => ({
          fromId: link.from.id,
          toId: link.to.id,
          fromText: link.fromText,
          toText: link.toText
        }));
        
        await db.collection('users').doc(currentUser.uid).collection('graphs').doc('mainGraph').set({
          notes: notesData,
          links: linksData,
          lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('✅ Saved to Firebase!');
      } catch (error) {
        console.error('❌ Error saving:', error);
      }
    }

    async function loadFromFirebase() {
      if (!currentUser) return;
      
      try {
        const doc = await db.collection('users').doc(currentUser.uid).collection('graphs').doc('mainGraph').get();
        
        if (doc.exists) {
          const data = doc.data();
          
          notes = data.notes.map(noteData => {
            const note = new Note(noteData.x, noteData.y, noteData.title, noteData.content);
            note.id = noteData.id;
            return note;
          });
          
          links = data.links.map(linkData => {
            const fromNote = notes.find(n => n.id === linkData.fromId);
            const toNote = notes.find(n => n.id === linkData.toId);
            if (fromNote && toNote) {
              return new Link(fromNote, toNote, linkData.fromText, linkData.toText);
            }
          }).filter(Boolean);
          
          console.log('✅ Loaded from Firebase!', notes.length, 'notes,', links.length, 'links');
        }
      } catch (error) {
        console.error('❌ Error loading:', error);
      }
    }

    let saveTimeout;
    function scheduleSave() {
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        saveToFirebase();
      }, 3000);
    }

    function createNote(x, y) {
      const note = new Note(x, y);
      notes.push(note);
      
      showNoteEditor(note, (savedNote) => {
        if (!savedNote.title && !savedNote.content) {
          notes = notes.filter(n => n.id !== note.id);
        }
        scheduleSave();
      });
    }

    function deleteNote(note) {
      notes = notes.filter(n => n.id !== note.id);
      links = links.filter(l => l.from.id !== note.id && l.to.id !== note.id);
      scheduleSave();
    }

    function startLinkCreation(fromNote) {
      linkMode = { step: 1, fromNote: fromNote, fromText: null };
      
      showNoteEditor(fromNote, (selectedText) => {
        linkMode.fromText = selectedText;
        linkMode.step = 2;
        document.getElementById('linkModeOverlay').classList.add('active');
      }, 'select');
    }

    function finishLinkCreation(toNote) {
      if (!linkMode || linkMode.step !== 2) return;
      
      document.getElementById('linkModeOverlay').classList.remove('active');
      
      showNoteEditor(toNote, (selectedText) => {
        const link = new Link(linkMode.fromNote, toNote, linkMode.fromText, selectedText);
        links.push(link);
        linkMode = null;
        scheduleSave();
      }, 'select');
    }

    // DESKTOP EVENT LISTENERS
    if (!isMobile) {
      canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const note = getNoteAt(e.clientX, e.clientY);
        showContextMenu(e.clientX, e.clientY, note);
      });

      canvas.addEventListener('click', (e) => {
        removeContextMenu();
        removeLinksPopup();
        
        if (linkMode && linkMode.step === 2) {
          const note = getNoteAt(e.clientX, e.clientY);
          if (note && note.id !== linkMode.fromNote.id) {
            finishLinkCreation(note);
          }
        }
      });

      canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0 && !linkMode) {
          const note = getNoteAt(e.clientX, e.clientY);
          if (note) {
            draggingNote = note;
            note.isDragging = true;
            hasDragged = false;
            canvas.style.cursor = 'grabbing';
          } else {
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
          }
        }
      });

      canvas.addEventListener('mousemove', (e) => {
        if (draggingNote) {
          hasDragged = true;
          const world = screenToWorld(e.clientX, e.clientY);
          draggingNote.x = world.x;
          draggingNote.y = world.y;
        } else if (isDragging) {
          const dx = e.clientX - dragStart.x;
          const dy = e.clientY - dragStart.y;
          camera.x += dx / camera.zoom;
          camera.y += dy / camera.zoom;
          dragStart = { x: e.clientX, y: e.clientY };
        }
      });

      canvas.addEventListener('mouseup', (e) => {
        if (draggingNote) {
          draggingNote.isDragging = false;
          const wasJustClick = !hasDragged;
          const clickedNote = draggingNote;
          draggingNote = null;
          canvas.style.cursor = 'grab';
          
          if (wasJustClick && !linkMode) {
            showNoteEditor(clickedNote, (savedNote) => {});
          }
        }
        isDragging = false;
      });

      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomSpeed = 0.1;
        const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
        camera.zoom = Math.max(0.1, Math.min(3, camera.zoom + delta));
      });
    } else {
      // MOBILE EVENT LISTENERS
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          touchStartTime = Date.now();
          touchStartPos = { x: touch.clientX, y: touch.clientY };
          touchStartNote = getNoteAt(touch.clientX, touch.clientY);
          
          if (touchStartNote && !linkMode) {
            isLongPress = false;
            
            // Start long-press timer
            longPressTimer = setTimeout(() => {
              isLongPress = true;
              touchStartNote.isDragging = true;
              
              // Haptic feedback
              if (navigator.vibrate) {
                navigator.vibrate(10);
              }
              
              // Show hint
              const hint = document.getElementById('dragHint');
              hint.classList.add('show');
              setTimeout(() => {
                hint.classList.remove('show');
              }, 1500);
              
              canvas.style.cursor = 'grabbing';
            }, LONG_PRESS_DURATION);
          }
        }
      }, { passive: false });

      canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && (isLongPress || isDragging)) {
          e.preventDefault();
          
          const touch = e.touches[0];
          
          if (touchStartNote && touchStartNote.isDragging) {
            // Dragging note
            const world = screenToWorld(touch.clientX, touch.clientY);
            touchStartNote.x = world.x;
            touchStartNote.y = world.y;
            hasDragged = true;
          } else if (isDragging) {
            // Panning canvas
            const dx = touch.clientX - dragStart.x;
            const dy = touch.clientY - dragStart.y;
            camera.x += dx / camera.zoom;
            camera.y += dy / camera.zoom;
            dragStart = { x: touch.clientX, y: touch.clientY };
            hasDragged = true;
          }
        } else if (e.touches.length === 2) {
          e.preventDefault();
          // Could add pinch zoom here
        }
      }, { passive: false });

      canvas.addEventListener('touchend', (e) => {
        clearTimeout(longPressTimer);
        
        if (touchStartNote) {
          const currentTime = Date.now();
          const touchDuration = currentTime - touchStartTime;
          
          if (touchStartNote.isDragging) {
            // End dragging
            touchStartNote.isDragging = false;
            canvas.style.cursor = 'grab';
            hasDragged = false;
            touchStartNote = null;
          } else if (touchDuration < LONG_PRESS_DURATION && !hasDragged) {
            // Short tap on note
            const timeSinceLastTap = currentTime - lastTapTime;
            
            if (lastTapNote === touchStartNote && timeSinceLastTap < DOUBLE_TAP_DELAY) {
              // DOUBLE TAP - Open note editor with mobile buttons
              lastTapNote = null;
              lastTapTime = 0;
              removeContextMenu();
              removeLinksPopup();
              showNoteEditor(touchStartNote, (savedNote) => {
                scheduleSave();
              }, 'edit', null, true);
            } else {
              // SINGLE TAP - Open note editor or handle linking
              if (linkMode && linkMode.step === 2) {
                // In linking mode - finish the link
                finishLinkCreation(touchStartNote);
              } else {
                // Normal edit mode
                lastTapNote = touchStartNote;
                lastTapTime = currentTime;
                removeContextMenu();
                removeLinksPopup();
                showNoteEditor(touchStartNote, (savedNote) => {
                  scheduleSave();
                }, 'edit', null, true);
              }
            }
          }
        } else if (!hasDragged && e.touches.length === 0) {
          // Tap on empty canvas
          const currentTime = Date.now();
          const touchDuration = currentTime - touchStartTime;
          
          if (touchDuration < LONG_PRESS_DURATION && !isLongPress) {
            const timeSinceLastTap = currentTime - lastTapTime;
            
            if (lastTapNote === null && timeSinceLastTap < DOUBLE_TAP_DELAY) {
              // DOUBLE TAP on empty - create new note
              lastTapTime = 0;
              const world = screenToWorld(touchStartPos.x, touchStartPos.y);
              createNote(world.x, world.y);
            } else {
              lastTapTime = currentTime;
              lastTapNote = null;
            }
          }
        }
        
        isDragging = false;
        isLongPress = false;
        hasDragged = false;
        touchStartNote = null;
      }, { passive: false });

      canvas.addEventListener('touchcancel', (e) => {
        clearTimeout(longPressTimer);
        if (touchStartNote) {
          touchStartNote.isDragging = false;
          canvas.style.cursor = 'grab';
        }
        isDragging = false;
        isLongPress = false;
        hasDragged = false;
        touchStartNote = null;
      }, { passive: false });
    }

    canvas.addEventListener('click', (e) => {
      if (!isMobile) {
        removeContextMenu();
        removeLinksPopup();
        
        if (linkMode && linkMode.step === 2) {
          const note = getNoteAt(e.clientX, e.clientY);
          if (note && note.id !== linkMode.fromNote.id) {
            finishLinkCreation(note);
          }
        }
      }
    });

    document.body.addEventListener('touchmove', (e) => {
      // Allow touchmove on inputs
      if (e.target.tagName !== 'INPUT' && e.target.getAttribute('contenteditable') !== 'true') {
        e.preventDefault();
      }
    }, { passive: false });

    window.addEventListener('resize', () => {
      resizeCanvasForDevice();
    });

    // Authentication handlers
    document.getElementById('googleSignInBtn').addEventListener('click', async () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      try {
        await auth.signInWithPopup(provider);
      } catch (error) {
        console.error('❌ Sign-in error:', error);
        alert('Sign-in failed. Please try again.');
      }
    });

    document.getElementById('logoutBtn').addEventListener('click', async () => {
      try {
        await auth.signOut();
      } catch (error) {
        console.error('❌ Sign-out error:', error);
      }
    });

    // Auth state observer
    auth.onAuthStateChanged(async (user) => {
      if (user) {
        currentUser = user;
        console.log('✅ Signed in as:', user.displayName);
        
        document.getElementById('loginOverlay').style.display = 'none';
        document.getElementById('userInfo').style.display = 'flex';
        document.getElementById('userName').textContent = user.displayName;
        document.getElementById('userAvatar').src = user.photoURL;
        
        await loadFromFirebase();
        
        if (notes.length === 0) {
          notes.push(new Note(-200, -100, 'Welcome', 'Right-click (desktop) or double-tap (mobile) to create a new note or add links!'));
          notes.push(new Note(200, 100, 'Mobile Controls', 'Hold and drag to move notes. Single tap to open. Double tap for menu.'));
          saveToFirebase();
        }
      } else {
        currentUser = null;
        notes = [];
        links = [];
        
        document.getElementById('loginOverlay').style.display = 'flex';
        document.getElementById('userInfo').style.display = 'none';
        
        console.log('ℹ️ Signed out');
      }
    });

    animate();
  </script>
</body>
</html>
